[[introduction-to-scala]]
Introduction to Scala
---------------------

image::images/smooth-spiral.png[logo]

----------------------------------------------------------------------
Introduction to
                     __                                               
     ________ ___   / /  ___  
    / __/ __// _ | / /  / _ | 
  __\ \/ /__/ __ |/ /__/ __ | 
 /____/\___/_/ |_/____/_/ | | 
                          |/  Programming Language

Saleem Ansari (@tuxdna)
----------------------------------------------------------------------

'''''

[[outline]]
Outline
-------

[[using-scala]]
Using Scala
~~~~~~~~~~~

[[functional-programming-in-scala]]
Functional Programming in Scala
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

[[object-oriented-programming-in-scala]]
Object Oriented Programming in Scala
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

[[questionanswer]]
Question/Answer
~~~~~~~~~~~~~~~

'''''

[[basic-introduction]]
Basic introduction
------------------

* What is Scala?
* Scala tools
* Basic Data Types
* Collections
* if-else, loops, case-match, exception handling

'''''

[[what-is-scala]]
What is Scala?
--------------

Scala stands for "scalable language". The language is so named because it was designed to grow with demands of its users.

This is what makes Scala a "scalable language":

* Scala is: compiled, statically typed, strictly typed, type inferred, fast, concise, expressive, pleasant to use, and high level
* Scala is: Object Oriented, Functional and Imperative, runs on JVM, is compatible with Java

Compare it to other languages such as Python, Ruby etc., which are interpretted, dynamically typed and so on.

image::images/scala.png[image]

'''''

[[jvm-languages]]
JVM Languages
-------------

image::images/jvm-languages.png[JVM Languages]

'''''

[[scala-tools]]
Scala Tools
-----------

* `scala` -- The Scala Interperter ( think of `java` )
* `scalac` -- The Scala Compiler ( think of `javac` )
* `sbt` -- Scala Build Tool ( think of Ant, Ivy, Maven etc. )
* ScalaIDE -- Eclipse IDE with Scala plugins
* Other IDE also support Scala ( IntelliJ, Netbeans etc. )

Scala REPL - Read Eval Print Loop

-------------------------------------------------------------------------
$ scala
Welcome to Scala version 2.9.1 (OpenJDK 64-Bit Server VM, Java 1.7.0_51).
Type in expressions to have them evaluated.
Type :help for more information.

scala> println("Hello Scala World!")
Hello Scala World!

scala> 
-------------------------------------------------------------------------

'''''

[[basic-data-types]]
Basic Data Types
----------------

Basic Data Types: ( all integers are signed two's complement )

* Integers: `Byte` (8bit), `Short` (16bit), `Int` (32bit), `Long`
(64bit)
* `Char` (16 bit unicode character), `String` (squence of Chars)
* Reals: `Float` (32bit), `Double` (64bit)
* `Boolean`: either `true` or `false`

Literals

* Basic data types: `1`, `0.123`, `12L`, `'a'`, `"String"`
* Symbol literal: `'identifier`

'''''

[[type-hierarchy]]
Type Hierarchy
--------------

image::images/classhierarchy.png[class hierarchy]

'''''

[[collections]]
Collections
-----------

In addition to Java collections Scala provides:

* `List` ( similar to java.util.LinkedList )
* `Array` ( similar to Java array )
* `Set` ( similar to java.util.Set )
* `Map` ( similar to java.util.Map )
* `Tuple` ( Java doesn't have a Tuple )

Immutability

* Immutable collections ( scala.collection.immutable ) -- benefits: no
locks to be acquired
* Mutable collections ( scala.collection.mutable )

[[list-array]]
List / Array
------------

image::images/list2.png[many elements]

image::images/array.png[array elements]

------------------------------------------------------
!scala
scala> val lst = List(1,2,3,4,5,6,7,8,10)
lst: List[Int] = List(1, 2, 3, 4, 5, 6, 7, 8, 10)

scala> val arr = Array(1,2,3,4,5,6,7,8,9,10)
arr: Array[Int] = Array(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)
------------------------------------------------------

'''''

[[map-set]]
Map / Set
---------

image::images/map.png[map]

image::images/set.png[set]

-----------------------------------------------------------------------------
!scala
scala> val romans = Map("I" -> 1, "II" -> 2, "III" -> 3, "IV" -> 4, "V" -> 5)
romans: scala.collection.immutable.Map[java.lang.String,Int] = Map(II -> 2, 
    IV -> 4, I -> 1, V -> 5, III -> 3)

scala> val r = Set("I", "II", "III", "IV", "V")
r: scala.collection.immutable.Set[java.lang.String] = Set(II, IV, I, V, III)
-----------------------------------------------------------------------------

[[basic-program-constructs]]
Basic program constructs
------------------------

* if-else expression
* loops: for comprehension
* pattern matching
* exception handling

'''''

[[if-else]]
if-else
-------

-------------------------------------------------------------------------
!scala
scala> import java.util.Calendar
import java.util.Calendar

scala> val now = Calendar.getInstance()
now: java.util.Calendar = java.util.GregorianCalendar[time=1392732373004,
  areFieldsSet=true,areAllFieldsSet=true,lenient=true,
  zone=sun.util.calendar.ZoneInfo[id="Asia/Kolkata",offset=19800000,
  dstSavings=0,useDaylight=false,transitions=6,lastRule=null],
  firstDayOfWeek=1,minimalDaysInFirstWeek=1,ERA=1,YEAR=2014,MONTH=1,
  WEEK_OF_YEAR=8,WEEK_OF_MONTH=4,DAY_OF_MONTH=18,DAY_OF_YEAR=49,
  DAY_OF_WEEK=3,DAY_OF_WEEK_IN_MONTH=3,AM_PM=1,HOUR=7,HOUR_OF_DAY=19,
  MINUTE=36,SECOND=13,MILLISECOND=4,ZONE_OFFSET=19800000,DST_OFFSET=0]

scala> val hour = now.get(Calendar.HOUR_OF_DAY)
hour: Int = 19

scala> println( if(hour < 12) "good afternoon" else "good morning")
good morning
-------------------------------------------------------------------------

'''''

[[loops]]
Loops
-----

--------------------------------------------------------------------------------
!scala
scala> val numbers = (1 to 10) toList
numbers: List[Int] = List(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)

scala> for(n <- numbers) print(n + " ")
1 2 3 4 5 6 7 8 9 10 

scala> var index = 0
index: Int = 0

scala> while(index < numbers.length) { print(numbers(index) + " "); index += 1 }
1 2 3 4 5 6 7 8 9 10 
--------------------------------------------------------------------------------

'''''

[[pattern-matching]]
Pattern matching
----------------

------------------------------------------------
!scala
scala> val dow = now.get(Calendar.DAY_OF_WEEK)
dow: Int = 3

scala> dow match {
        case 1 => "Sunday"
        case 2 => "Monday"
        case 3 => "Tuesday"
        case 4 => "Wednesday"
        case 5 => "Thursday"
        case 6 => "Friday"
        case 7 => "Saturday"
      }
res20: java.lang.String = Tuesday

scala> dow match {
        case x if x == 1  || x == 7 => "Weekend"
        case _ => "Workday"
      }
res21: java.lang.String = Workday
------------------------------------------------

'''''

[[exception-handling]]
Exception handling
------------------

-------------------------------------------------------------------
!scala
scala> var divisor = 0
divisor: Int = 0

scala> def divide(n: Int) = 1 / divisor
divide: (n: Int)Int

scala> def divide(n: Int) = n / divisor
divide: (n: Int)Int

scala> try { divide(10) } catch {
         case e: ArithmeticException => "Check your calculations!" 
       }
res34: Any = Check your calculations!

scala> divisor = 2
divisor: Int = 2

scala> try { divide(10) } catch {
         case e: ArithmeticException => "Check your calculations!"
       }
res35: Any = 5
-------------------------------------------------------------------

'''''

[[functional-programming]]
Functional Programming
----------------------

Lambda calculus: (closure, functions and values, higher order functions,
recursion)

image::images/lambda.png[lambda]

* First-class and higher-order functions
* Pure functions
* Recursion
* Strict versus non-strict evaluation
* Type systems

'''''

[[defining-functions]]
Defining functions
------------------

image::images/function_composition.png[map/filter]

-------------------------------
!scala
scala> def f(x: Double) = x * x
f: (x: Double)Double

scala> def g(y: Double) = 1 / y
g: (y: Double)Double
-------------------------------

[[first-class-function]]
First class function
--------------------

A function is treated same as any other variable. Which means we can
store a function in a variable. According to Wikipedia:

* such a language supports passing functions as arguments to other
functions, returning them as the values from other functions, and
assigning them to variables or storing them in data structures.
* Some programming language theorists require support for anonymous
functions as well.
* In languages with first-class functions, the names of functions do not
have any special status; they are treated like ordinary variables with a
function type.

Example:

---------------------------------------------
!scala
scala> def add(a:Int, b:Int) = a + b
add: (a: Int, b: Int)Int

scala> val myfunc = (a: Int, b: Int) => a + b
myfunc: (Int, Int) => Int = <function2>

scala> val otherfunc = add _
otherfunc: (Int, Int) => Int = <function2>
---------------------------------------------

'''''

[[higher-order-function]]
Higher order function
---------------------

In mathematics and computer science, a higher-order function (also
functional form, functional or functor) is a function that does at least
one of the following:

* takes one or more functions as an input
* outputs a function

Example

----------------------------------------------------------------
!scala
scala> def transform(fn: (Int) => Int, number: Int) = fn(number)
transform: (transformer: Int => Int, number: Int)Int

scala> val plus5 = transform( (x: Int) => x + 5, _: Int)
plus5: Int => Int = <function1>

scala> val into3 = transform( (x: Int) => x * 3, _: Int)
into3: Int => Int = <function1>

scala> plus5(6)
res6: Int = 11

scala> into3(6)
res7: Int = 18
----------------------------------------------------------------

'''''

[[pure-functions]]
Pure functions
--------------

Pure functions have no side effects (memory or I/O). This means:

* Compiler can discard or optimize out the return value if it was not
used in an expression
* The same result is returned for same parameters i.e. one-to-one
correspondence or mapping. This can enable caching optimizations such as
memoization.
* Two independent functions can be evaluated out of order, or in
parallel without worrying about side-effects.
* Same strategy can be applied by the compiler if the entire program has
many independent functions i.e. many parts of the whole program can run
in parrallel, withoug baking-in any paralleism logic!

Example:

----------------------------------------------------------------------------
!scala
scala> def stat(num: List[Int]) = { (num.sum, num.sum/num.length.toDouble) }
stat: (num: List[Int])(Int, Double)

scala> val list1 = List(1,2,3,4,5); val list2 = List(6,7,8,9,10)
list1: List[Int] = List(1, 2, 3, 4, 5)
list2: List[Int] = List(6, 7, 8, 9, 10)

scala> (stat(list1), stat(list2))
res57: ((Int, Double), (Int, Double)) = ((15,3.0),(40,8.0))
----------------------------------------------------------------------------

'''''

[[recursion]]
Recursion
---------

A function can call itself, over and over, until a base-case is reached.

[[factorial]]
Factorial
~~~~~~~~~

image::images/factorial-function.png[factorial]

--------------------------------------
!scala
scala> def factorial(n: Int): Int = { 
           if(n=0) 1 
           else n*factorial(n-1)
       }
factorial: (n: Int)Int

scala> factorial(5)
res2: Int = 120
--------------------------------------

'''''

[[strict-versus-non-strict-evaluation]]
Strict versus non-strict evaluation
-----------------------------------

Lazy val

------------------------------------------
!scala
scala> lazy val a = b + 1; lazy val b = 1;
a: Int = <lazy>
b: Int = <lazy>

scala> a
res36: Int = 2

scala> b
res37: Int = 1
------------------------------------------

Call by name

----------------------------------------------------------------------------------------
!scala
scala> def withinTx(block: () => Unit) = { println("Begin TX"); block() ;
                                            println("End TX") }
withinTx: (block: () => Unit)Unit

scala> withinTx { () => println("Performing operation") }
Begin TX
Performing operation
End TX

scala> def insideTx(block: => Unit) = { println("Begin TX"); block ; println("End TX") }
insideTx: (block: => Unit)Unit

scala> insideTx { println("Performing operation") }
Begin TX
Performing operation
End TX
----------------------------------------------------------------------------------------

'''''

[[type-systems]]
Type Systems
------------

* Typed functions
* Type bounds ( view bounds, context bounds, manifest context bounds )
* Variance: co-variant / contra-variant
* Wildcards

'''''

[[mapreduce]]
MapReduce
---------

map -> shuffle -> reduce
image::images/mapreduce_mapshuffle.png[map-shuffle-reduce]

----------------------------------------------------------
!scala
scala> val result = (1 to 20).map(x => x*x).groupBy(_ % 5)
    .par.map{ y => y._2.sum }.sum
result: Int = 2870
----------------------------------------------------------

'''''

[[object-oriented-programming]]
Object Oriented Programming
---------------------------

* Traits
* Objects
* Classes
* Companion Objects ( inside same source file )
* Structural Types

'''''

[[let-us-make-some-engines]]
Let us make some engines
------------------------

Stroke Engines

image::images/StrokeEngine.png[StrokeEngine]

'''''

Steam Engine

image::images/SteamEngine.png[SteamEngine]

'''''

[[engines]]
Engines
-------

-----------------------------------------------------------------
!java
package oop;
import java.util.Arrays;
public class MyEngines {
    enum FuelLevel {Empty, Reserve, Half, Full}
    interface Startable { public void start(); }
    interface Stoppable { public void stop(); }
    
    abstract class Engine implements Startable, Stoppable { ... }
    class TwoStrokeEngine extends Engine { ... }
    class FourStrokeEngine extends Engine { ... }
    
    interface Make { ... }
    class SteamEngine extends Engine implements Make { ... }
    
    public static void main() { ... }
}
    
-----------------------------------------------------------------

Continued on next slide...

'''''

[[abstract-class-engine]]
abstract class Engine
---------------------

---------------------------------------------------------------------------------------------------
!java
abstract class Engine implements Startable, Stoppable {
    int horsePower;
    FuelLevel fuelLevel;
    boolean running = false;
    public Engine(int hp, boolean state, FuelLevel fl) {
        this.horsePower = hp; this.running = state; this.fuelLevel = fl;
    }
    @Override
    public void start() {
        switch (fuelLevel) {
        case Empty:
            System.out.println("Cannot start without fuel.");
        default:
            if (!running) {
                running = true;
                System.out.println("Engine started");
            } else System.out.println("Engine already started");
        }
    }
    @Override
    public void stop() {
        if (running) {
            running = false; System.out.println("Engine stopped");
        }
    }
    @Override
    public String toString() {
        return String.format(
         "Engine(running: %s, fuelLevel: %s, horsePower: %d BHP)", running, fuelLevel, horsePower);
    }
}
---------------------------------------------------------------------------------------------------

'''''

[[twostrokeengine-fourstrokeengine]]
TwoStrokeEngine / FourStrokeEngine
----------------------------------

------------------------------------------------------------------
!java
class TwoStrokeEngine extends Engine {
    String model;
    public TwoStrokeEngine(int hp, boolean state, FuelLevel fl) {
        super(hp, state, fl);
    }
    @Override
    public String toString() {
        return "TwoStroke" + super.toString();
    }
}

class FourStrokeEngine extends Engine {
    String model;
    public FourStrokeEngine(int hp, boolean state, FuelLevel fl) {
        super(hp, state, fl);
    }
    @Override
    public String toString() {
        return "FourStroke" + super.toString();
    }
}
------------------------------------------------------------------

'''''

[[steamengine]]
SteamEngine
-----------

-------------------------------------------------------------------------------
!java
interface Make {
    public String make();
}

class SteamEngine extends Engine implements Make {
    String model = "IndianRailways";
    public SteamEngine(int hp, boolean state, FuelLevel fl) {
        super(hp, state, fl);
    }
    public SteamEngine(int hp, boolean state, FuelLevel fl, String modelName) {
        this(hp, state, fl);
        this.model = modelName;
    }
    @Override
    public String make() { return "SteamEngine - " + model; }
    @Override
    public String toString() {
        return "Steam" + super.toString();
    }
}
-------------------------------------------------------------------------------

'''''

[[make-some-engines-now...]]
make some engines now...
------------------------

---------------------------------------------------------------------------
!java
public static void main(String[] args) {

    MyEngines me = new MyEngines();

    FourStrokeEngine e1 = me.new FourStrokeEngine(40, false,
            FuelLevel.Empty);
    System.out.println(e1);
    e1.start(); // won't start
    e1.fuelLevel = FuelLevel.Full;
    e1.start(); // will start: fuel-tank is now full
    System.out.println(e1 + "\n");

    TwoStrokeEngine e2 = me.new TwoStrokeEngine(26, false, FuelLevel.Full);
    System.out.println(e2);
    e2.start();
    System.out.println(e2 + "\n");

    SteamEngine e3 = me.new SteamEngine(1800, true, FuelLevel.Reserve);
    System.out.println(e3);
    System.out.println(e3.make() + "\n");

    Engine[] myengines = { e1, e2, e3 };
    System.out.println(Arrays.asList(myengines) + "\n");
}
---------------------------------------------------------------------------

'''''

[[scala-version]]
Scala version
-------------

------------------------------------------------------------------------
!scala
package oop
object engine {
  object FuelLevel extends Enumeration {
    type FuelLevel = Value
    val Empty, Reserve, Half, Full = Value 
  }
  import FuelLevel._

  trait Stoppable {
    var running: Boolean
    var fuelLevel: FuelLevel
    def stop = if (running) {running = false; println("Engine stopped")}
  }

  trait Startable {
    var running: Boolean
    var fuelLevel: FuelLevel
    def start = fuelLevel match {
        case FuelLevel.Empty => println("Cannot start without fuel.")
        case _ if ! running => {
          running = true; println("Engine started")
        }
        case _ => println("Engine already running")
      }
  }
------------------------------------------------------------------------

[[scala-version-...]]
Scala version ...
-----------------

-------------------------------------------------------------
!scala
  def main(args: Array[String]) {
    val e1 = new FourStrokeEngine(40, false, FuelLevel.Empty)
    println(e1)
    e1.start // won't start
    e1.fuelLevel = FuelLevel.Full
    e1.start // will start: fuel-tank is now full
    println(e1 + "\n")

    val e2 = new TwoStrokeEngine(40, false, FuelLevel.Full)
    println(e2)
    e2.start
    println(e2 + "\n")

    val e3 = new SteamEngine(300, true, FuelLevel.Reserve)
    println(e3)
    println(e3.make + "\n")

    val myengines = Array(e1, e2, e3)
    println(myengines + "\n")
  }
}
-------------------------------------------------------------

'''''

[[traits]]
Traits
------

Just like java has Interface, Scala has Traits, but with definitions.

--------------------
!scala
trait Animal {
   def name: String
   def lifespan: Int
}
--------------------

Java:

-------------------------
!java
interface Animal {
   public String name();
   public int lifespan();
}
-------------------------

'''''

[[objects]]
Objects
-------

Object is a singleton

---------------------------------------------------------------------------
!scala
object Animal {
  // object body
  def method1(p1: Int, p2: String): String = { /* some operations here */ }
}
---------------------------------------------------------------------------

'''''

[[classes]]
Classes
-------

---------------------------------------------------------------------------
!scala
class Animal {
  // class body
  def method1(p1: Int, p2: String): String = { /* some operations here */ }
}
---------------------------------------------------------------------------

[[structural-types]]
Structural Types
----------------

'''''

[[recap]]
Recap
-----

* Using Scala: Scala tools, Basic Data Types, Collections, if-else,
loops, case-match, exception handling
* Functional Programming in Scala: closure, functions and values, higher
order functions, recursion
* Object Oriented Programming in Scala: Traits, Objects, Classes,
Companion Objects, Structural Types

'''''

[[use-cases-of-scala]]
Use cases of Scala
------------------

* Scala is like a swiss-army-knife. But you only need a normal knife to
cut an apple.
* Remember, Scala is a JVM language ( uptil now )!
* Applications which already run on the JVM
* Enterprise Integration
* Web Services
* Quick prototyping
* Concurrent applications for multi-core machines: RxScala, Akka ( based
on Erlang's Actor Model )
* Domain Specific Languages
* And for fun!

'''''

[[questions]]
Questions
---------

'''''

[[thanks-and-happy-coding--]]
Thanks and happy coding :-)
---------------------------

'''''

[[references]]
References
----------

* http://manning.com/bjarnason/FPiS_meap_ch01.pdf[Introduction to
Function Programming]
* https://en.wikipedia.org/wiki/Functional_programming[Functional
Programming] Wikipedia Article
*
http://www.codeproject.com/Articles/375166/Functional-programming-in-Csharp[Functional
programming in C#]
* link:www.scala-lang.org[Scala Lang site]
*
http://zeroturnaround.com/rebellabs/the-adventurous-developers-guide-to-jvm-languages-java-scala-groovy-fantom-clojure-ceylon-kotlin-xtend/[The
Adventurous Developer's Guide to JVM Languages]
* https://www.artima.com/pins1ed/[Programming in Scala 1st Edition]
* http://www.jsphostingsolutions.com/JAVA-tutorial[Java Tutorial]

